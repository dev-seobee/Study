# JVM의 구성요소
- 클래스 로더(Class Loader)
- 실행 엔진(Execution Engine)
  - 인터프리터
  - JIT 컴파일러
  - 가비지 콜렉터
- 런타임 데이터 영역

## 클래스 로더
JVM 내로 클래스 파일(*.class)을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈
런 타임시 동적으로 클래스를 로드하고 jar파일 내 저장된 클래스들을 JVM위에 탑재한다.
클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크하는 역할을 진행.

## 실행 엔진
클래스를 실행시키는 역할.
클래스 로더가 JVM내의 런타임 데이터 영역에 바이트 코드를 배치시키고, 이를 실행 엔진에 의해 실행된다.

### 인터프리터
실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행.
한줄 씩 수행하기 때문에 느리다는 단점이 존재.

### JIT 컴파일러
인터프리터 방식으로 실행하다가, 적절한 시점에 바이트 코드 전체를 컴파일하여 기계어로 변경하고,
이후에는 기계어로 직접 실행하는 방식.

### 가비지 컬렉터
더이상 사용되지 않는 인스턴스를 찾아 메모리를 삭제한다.

#### [Minor GC & Major GC]
JVM의 힙영역은 처음 설계될 때 다음의 2가지를 전제로 설계가 되었다.
- 대부분의 객체는 금방 접근 불가능한 상태가 된다.
- 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.

<b>즉, 객체는 대부분 일회성이며, 메모리에 오랫동안 남아있는 경우는 드물다</b>는 것.
따라서, 생존 기간에 따라 물리적인 힙 영역을 나누게 되었고, Young, Old 총 2가지 영역으로 설계 되어짐

< Young 영역 >
- 새롭게 객체가 할당되는 영역
- 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에, 많은 객체가 Young영역에 생성되었다가 사라짐
- Young영역에 대한 가비지 컬렉션을 <font color="red">Minor GC</font>라고 불리움.

< Old 영역 >
- Young 영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역.
- Young 영역보다 크게 할당되며, 영역의 크기가 큰 만큼 가비지는 적게 발생.
- Old 영역에 대한 가비지 컬렉션을 <font color="red">Major GC 또는 Full GC</font>라고 부른다.

예외의 상황으로, Old 영역에 있는 객체가 Young영역의 객체를 참조하는 경우,
Old 영역에 512바이트의 덩어리(chunck)로 되어있는 카드 테이블이 존재.

`카드 테이블`에는  Old 영역에 있는 객체가 Young영역의 객체를 참조할 때 마다 그에 대한 정보가 표시된다.

## GC실행시 일어나는 일
GC가 실행될 때 아래의 두 단계를 거쳐서 진행된다.
- Stop the World
- Mark and Sweep

## Stop the world
GC 쓰레드를 제외한 모든 쓰레드들의 작업이 중단되고 GC가 완료되면 작업이 재개된다.

## Mark and Sweep
- Mark : 사용되는 메모리와 사용되지 않는 메모리를 선별하는 작업
- Sweep : Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제 하는 작업.


https://mangkyu.tistory.com/119 GC 알고리즘
