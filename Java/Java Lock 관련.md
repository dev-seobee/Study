
# 트랜잭션
트랜잭션의 경우 아래의 4가지 특징을 가진다.
- 원자성
    더 이상 분해가 불가능한 업무의 최소 단위.
    전부 처리되거나 하나도 처리되지 않아야 한다.
- 일관성
    일관된 상태의 데이터베이스에서 하나의 트랜잭션을 성공적으로 완료하고 나면 그 데이터베이스는 여전히 일관된 상태여야 한다.
- 격리성
    실행 중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없다.
- 영속성
  트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 데이터베이스에 영속적으로 저장된다.

## 트랜잭션의 격리성
막연하게 접근 할 수 없다라기 보단, 일반적으로 접근 레벨이 존재하며,
DB에 따라 설정이 가능하다. 격리성을 강하게 처리할 수 있으며, 약하게도 처리가 가능.

> 격리성으로 인해 나타날 수 있는 문제는 아래의 3가지 문제가 존재한다.
> - Dirty Read
> - Non-Repeatable Read
> - Phantom Read

### Dirty Read
다른 트랜잭션에 의해 수정됐지만, 아직 커밋되지 않은 데이터를 읽은 것.

### Non-Repeatable Read
한 트랜잭션 내에서 같은 Key를 가진 Row를 두 번 읽었는데, 그 사이에 값이 변경되거나 삭제되어 결과가 다르게 나타나는 현상

### Phantom Read
한 트랜잭션 내에서 같은 쿼리를 두번 수정했는데, 첫번째 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상.
여러 건을 요청하는 것에 대해서 데이터 값이 변경되는 것.


## 지정할 수 있는 격리성 수준
> 지정할 수 있는 격리성의 수준은 아래의 네가지로 나뉜다.
> - Read Uncommitted
> - Read Committed
> - Repeatable Read
> - Serializable Read
> 
### Read Committed
트랜잭션에서 처리중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
해당 수준에서 Dirty read, Non-Repeatable Read, Phantom Read가 일어날 수 있다.
이 설정의 경우 정합성에 문제가 있기 때문에 권장하는 설정이 아님.

### Read Committed
트랜잭션이 커밋되어 확정된 데이터만 다른 트랜잭션이 읽도록 허용
DirtyRead의 발생 가능성을 막습니다.
Repeatable Read, Phantom Read은 막지 못함.

### Repeatable Read
트랜잭션내에서 삭제, 변경에 대해서 Undo로그에 넣어두고 앞서 발생한 트랜잭션에 대해서는 실제 데이터가 아닌 Undo로그에 있는 백업 데이터를 읽게 합니다.
이로인해 삭제 수정의 데이터 불일치를 가져오던 Non-Repeatable Read를 해소할 수 있다.

### Serializable Read
트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지 않도록 하는 설정.

---

# 비관적 락(pessimistic lock)
Repeatable Read 또는 Serializable 정도의 격리성 수준을 제공.
트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작하는 방법.
> Shared Lock을 걸게 되면 write를 하기 위해서 Exclucive Lock을 얻어야 하는데, Shared Lock이 다른 트랜잭션에 의해서 걸려 있으면 해당 Lock을 얻지 못해서 업데이트를 할 수 없다. 수정을 하기 위해서는 해당 트랜잭션을 제외한 모든 트랜잭션이 종료(commit) 되어야 합니다.

트랜잭션을 이용하여 충돌을 예방하는 것이 바로 비관적 락.

# 낙관적 락(Optimistic Lock)

